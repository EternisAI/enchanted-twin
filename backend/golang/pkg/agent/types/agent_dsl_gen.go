// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type AgentDslSchemaJson struct {
	// Agent corresponds to the JSON schema field "agent".
	Agent AgentHeader `json:"agent" yaml:"agent" mapstructure:"agent"`

	// Graph corresponds to the JSON schema field "graph".
	Graph Graph `json:"graph" yaml:"graph" mapstructure:"graph"`

	// OnFinish corresponds to the JSON schema field "on_finish".
	OnFinish OnFinish `json:"on_finish" yaml:"on_finish" mapstructure:"on_finish"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentDslSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["agent"]; raw != nil && !ok {
		return fmt.Errorf("field agent in AgentDslSchemaJson: required")
	}
	if _, ok := raw["graph"]; raw != nil && !ok {
		return fmt.Errorf("field graph in AgentDslSchemaJson: required")
	}
	if _, ok := raw["on_finish"]; raw != nil && !ok {
		return fmt.Errorf("field on_finish in AgentDslSchemaJson: required")
	}
	type Plain AgentDslSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentDslSchemaJson(plain)
	return nil
}

type AgentHeader struct {
	// Budget corresponds to the JSON schema field "budget".
	Budget AgentHeaderBudget `json:"budget" yaml:"budget" mapstructure:"budget"`

	// Description corresponds to the JSON schema field "description".
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Inputs corresponds to the JSON schema field "inputs".
	Inputs JSONSchema `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// Llm corresponds to the JSON schema field "llm".
	Llm AgentHeaderLlm `json:"llm" yaml:"llm" mapstructure:"llm"`

	// Outputs corresponds to the JSON schema field "outputs".
	Outputs JSONSchema `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Provides corresponds to the JSON schema field "provides".
	Provides []ToolDef `json:"provides,omitempty" yaml:"provides,omitempty" mapstructure:"provides,omitempty"`

	// Queries corresponds to the JSON schema field "queries".
	Queries AgentHeaderQueries `json:"queries,omitempty" yaml:"queries,omitempty" mapstructure:"queries,omitempty"`

	// Schedule corresponds to the JSON schema field "schedule".
	Schedule *string `json:"schedule,omitempty" yaml:"schedule,omitempty" mapstructure:"schedule,omitempty"`

	// Signals corresponds to the JSON schema field "signals".
	Signals AgentHeaderSignals `json:"signals,omitempty" yaml:"signals,omitempty" mapstructure:"signals,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

type AgentHeaderBudget struct {
	// MaxSteps corresponds to the JSON schema field "max_steps".
	MaxSteps int `json:"max_steps" yaml:"max_steps" mapstructure:"max_steps"`

	// MaxTokensTotal corresponds to the JSON schema field "max_tokens_total".
	MaxTokensTotal int `json:"max_tokens_total" yaml:"max_tokens_total" mapstructure:"max_tokens_total"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentHeaderBudget) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["max_steps"]; raw != nil && !ok {
		return fmt.Errorf("field max_steps in AgentHeaderBudget: required")
	}
	if _, ok := raw["max_tokens_total"]; raw != nil && !ok {
		return fmt.Errorf("field max_tokens_total in AgentHeaderBudget: required")
	}
	type Plain AgentHeaderBudget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 1 > plain.MaxSteps {
		return fmt.Errorf("field %s: must be >= %v", "max_steps", 1)
	}
	if 1 > plain.MaxTokensTotal {
		return fmt.Errorf("field %s: must be >= %v", "max_tokens_total", 1)
	}
	*j = AgentHeaderBudget(plain)
	return nil
}

type AgentHeaderLlm struct {
	// MaxTokens corresponds to the JSON schema field "max_tokens".
	MaxTokens *int `json:"max_tokens,omitempty" yaml:"max_tokens,omitempty" mapstructure:"max_tokens,omitempty"`

	// Model corresponds to the JSON schema field "model".
	Model string `json:"model" yaml:"model" mapstructure:"model"`

	// Temperature corresponds to the JSON schema field "temperature".
	Temperature *float64 `json:"temperature,omitempty" yaml:"temperature,omitempty" mapstructure:"temperature,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentHeaderLlm) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["model"]; raw != nil && !ok {
		return fmt.Errorf("field model in AgentHeaderLlm: required")
	}
	type Plain AgentHeaderLlm
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MaxTokens != nil && 1 > *plain.MaxTokens {
		return fmt.Errorf("field %s: must be >= %v", "max_tokens", 1)
	}
	if plain.Temperature != nil && 1 < *plain.Temperature {
		return fmt.Errorf("field %s: must be <= %v", "temperature", 1)
	}
	if plain.Temperature != nil && 0 > *plain.Temperature {
		return fmt.Errorf("field %s: must be >= %v", "temperature", 0)
	}
	*j = AgentHeaderLlm(plain)
	return nil
}

type AgentHeaderQueries map[string]map[string]interface{}

type AgentHeaderSignals map[string]map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentHeader) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["budget"]; raw != nil && !ok {
		return fmt.Errorf("field budget in AgentHeader: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in AgentHeader: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AgentHeader: required")
	}
	if _, ok := raw["llm"]; raw != nil && !ok {
		return fmt.Errorf("field llm in AgentHeader: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in AgentHeader: required")
	}
	type Plain AgentHeader
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Za-z0-9_\-]+$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[A-Za-z0-9_\-]+$`)
	}
	if v, ok := raw["provides"]; !ok || v == nil {
		plain.Provides = []ToolDef{}
	}
	if matched, _ := regexp.MatchString(`^v?\d+\.\d+\.\d+$`, string(plain.Version)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Version", `^v?\d+\.\d+\.\d+$`)
	}
	*j = AgentHeader(plain)
	return nil
}

type Graph struct {
	// Nodes corresponds to the JSON schema field "nodes".
	Nodes []Node `json:"nodes" yaml:"nodes" mapstructure:"nodes"`

	// Revision corresponds to the JSON schema field "revision".
	Revision int `json:"revision" yaml:"revision" mapstructure:"revision"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Graph) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["nodes"]; raw != nil && !ok {
		return fmt.Errorf("field nodes in Graph: required")
	}
	if _, ok := raw["revision"]; raw != nil && !ok {
		return fmt.Errorf("field revision in Graph: required")
	}
	type Plain Graph
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Nodes != nil && len(plain.Nodes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "nodes", 1)
	}
	if 0 > plain.Revision {
		return fmt.Errorf("field %s: must be >= %v", "revision", 0)
	}
	*j = Graph(plain)
	return nil
}

// Arbitrary JSON-Schema fragment
type JSONSchema map[string]interface{}

type Node struct {
	// DependsOn corresponds to the JSON schema field "depends_on".
	DependsOn []string `json:"depends_on,omitempty" yaml:"depends_on,omitempty" mapstructure:"depends_on,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Prompt corresponds to the JSON schema field "prompt".
	Prompt string `json:"prompt" yaml:"prompt" mapstructure:"prompt"`

	// Rrule corresponds to the JSON schema field "rrule".
	Rrule *string `json:"rrule,omitempty" yaml:"rrule,omitempty" mapstructure:"rrule,omitempty"`

	// Spawn corresponds to the JSON schema field "spawn".
	Spawn NodeSpawn `json:"spawn" yaml:"spawn" mapstructure:"spawn"`

	// TaskArgs corresponds to the JSON schema field "task_args".
	TaskArgs NodeTaskArgs `json:"task_args,omitempty" yaml:"task_args,omitempty" mapstructure:"task_args,omitempty"`

	// Uses corresponds to the JSON schema field "uses".
	Uses []string `json:"uses,omitempty" yaml:"uses,omitempty" mapstructure:"uses,omitempty"`
}

type NodeSpawn string

const NodeSpawnChild NodeSpawn = "child"
const NodeSpawnInline NodeSpawn = "inline"
const NodeSpawnSchedule NodeSpawn = "schedule"

var enumValues_NodeSpawn = []interface{}{
	"inline",
	"child",
	"schedule",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NodeSpawn) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NodeSpawn {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NodeSpawn, v)
	}
	*j = NodeSpawn(v)
	return nil
}

type NodeTaskArgs map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Node) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Node: required")
	}
	if _, ok := raw["prompt"]; raw != nil && !ok {
		return fmt.Errorf("field prompt in Node: required")
	}
	if _, ok := raw["spawn"]; raw != nil && !ok {
		return fmt.Errorf("field spawn in Node: required")
	}
	type Plain Node
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["depends_on"]; !ok || v == nil {
		plain.DependsOn = []string{}
	}
	if v, ok := raw["uses"]; !ok || v == nil {
		plain.Uses = []string{}
	}
	*j = Node(plain)
	return nil
}

type OnFinish struct {
	// EmitSignal corresponds to the JSON schema field "emit_signal".
	EmitSignal OnFinishEmitSignal `json:"emit_signal" yaml:"emit_signal" mapstructure:"emit_signal"`
}

type OnFinishEmitSignal struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Payload corresponds to the JSON schema field "payload".
	Payload OnFinishEmitSignalPayload `json:"payload,omitempty" yaml:"payload,omitempty" mapstructure:"payload,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target string `json:"target" yaml:"target" mapstructure:"target"`
}

type OnFinishEmitSignalPayload map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFinishEmitSignal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in OnFinishEmitSignal: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in OnFinishEmitSignal: required")
	}
	type Plain OnFinishEmitSignal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OnFinishEmitSignal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFinish) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["emit_signal"]; raw != nil && !ok {
		return fmt.Errorf("field emit_signal in OnFinish: required")
	}
	type Plain OnFinish
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = OnFinish(plain)
	return nil
}

type ToolDef struct {
	// Description corresponds to the JSON schema field "description".
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Entrypoint corresponds to the JSON schema field "entrypoint".
	Entrypoint ToolDefEntrypoint `json:"entrypoint" yaml:"entrypoint" mapstructure:"entrypoint"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Parameters corresponds to the JSON schema field "parameters".
	Parameters JSONSchema `json:"parameters" yaml:"parameters" mapstructure:"parameters"`

	// Returns corresponds to the JSON schema field "returns".
	Returns JSONSchema `json:"returns,omitempty" yaml:"returns,omitempty" mapstructure:"returns,omitempty"`
}

type ToolDefEntrypoint struct {
	// Type corresponds to the JSON schema field "type".
	Type ToolDefEntrypointType `json:"type" yaml:"type" mapstructure:"type"`
}

type ToolDefEntrypointType string

const ToolDefEntrypointTypeQuery ToolDefEntrypointType = "query"
const ToolDefEntrypointTypeSignal ToolDefEntrypointType = "signal"
const ToolDefEntrypointTypeUpdate ToolDefEntrypointType = "update"
const ToolDefEntrypointTypeWorkflow ToolDefEntrypointType = "workflow"

var enumValues_ToolDefEntrypointType = []interface{}{
	"workflow",
	"query",
	"signal",
	"update",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolDefEntrypointType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolDefEntrypointType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolDefEntrypointType, v)
	}
	*j = ToolDefEntrypointType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolDefEntrypoint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolDefEntrypoint: required")
	}
	type Plain ToolDefEntrypoint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolDefEntrypoint(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolDef) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ToolDef: required")
	}
	if _, ok := raw["entrypoint"]; raw != nil && !ok {
		return fmt.Errorf("field entrypoint in ToolDef: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolDef: required")
	}
	if _, ok := raw["parameters"]; raw != nil && !ok {
		return fmt.Errorf("field parameters in ToolDef: required")
	}
	type Plain ToolDef
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolDef(plain)
	return nil
}
