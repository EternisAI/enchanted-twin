// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: holons.sql

package holons

import (
	"context"
	"database/sql"
	"time"
)

const addUserToHolon = `-- name: AddUserToHolon :exec
INSERT INTO holon_participants (holon_id, author_identity) 
VALUES (?, ?)
ON CONFLICT (holon_id, author_identity) DO NOTHING
`

type AddUserToHolonParams struct {
	HolonID        string `json:"holonId"`
	AuthorIdentity string `json:"authorIdentity"`
}

func (q *Queries) AddUserToHolon(ctx context.Context, arg AddUserToHolonParams) error {
	_, err := q.db.ExecContext(ctx, addUserToHolon, arg.HolonID, arg.AuthorIdentity)
	return err
}

const checkUserInHolon = `-- name: CheckUserInHolon :one
SELECT EXISTS(SELECT 1 FROM holon_participants WHERE holon_id = ? AND author_identity = ?)
`

type CheckUserInHolonParams struct {
	HolonID        string `json:"holonId"`
	AuthorIdentity string `json:"authorIdentity"`
}

func (q *Queries) CheckUserInHolon(ctx context.Context, arg CheckUserInHolonParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkUserInHolon, arg.HolonID, arg.AuthorIdentity)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createOrUpdateAuthor = `-- name: CreateOrUpdateAuthor :exec
INSERT INTO authors (identity, alias) 
VALUES (?, ?)
ON CONFLICT (identity) DO UPDATE SET alias = EXCLUDED.alias
`

type CreateOrUpdateAuthorParams struct {
	Identity string         `json:"identity"`
	Alias    sql.NullString `json:"alias"`
}

// Author queries
func (q *Queries) CreateOrUpdateAuthor(ctx context.Context, arg CreateOrUpdateAuthorParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateAuthor, arg.Identity, arg.Alias)
	return err
}

const createThread = `-- name: CreateThread :exec
INSERT INTO threads (id, title, content, author_identity, created_at, expires_at, image_urls, actions, views)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0)
`

type CreateThreadParams struct {
	ID             string       `json:"id"`
	Title          string       `json:"title"`
	Content        string       `json:"content"`
	AuthorIdentity string       `json:"authorIdentity"`
	CreatedAt      time.Time    `json:"createdAt"`
	ExpiresAt      sql.NullTime `json:"expiresAt"`
	ImageUrls      interface{}  `json:"imageUrls"`
	Actions        interface{}  `json:"actions"`
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) error {
	_, err := q.db.ExecContext(ctx, createThread,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.AuthorIdentity,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.ImageUrls,
		arg.Actions,
	)
	return err
}

const createThreadMessage = `-- name: CreateThreadMessage :exec
INSERT INTO thread_messages (id, thread_id, author_identity, content, created_at, is_delivered, actions)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateThreadMessageParams struct {
	ID             string      `json:"id"`
	ThreadID       string      `json:"threadId"`
	AuthorIdentity string      `json:"authorIdentity"`
	Content        string      `json:"content"`
	CreatedAt      time.Time   `json:"createdAt"`
	IsDelivered    bool        `json:"isDelivered"`
	Actions        interface{} `json:"actions"`
}

func (q *Queries) CreateThreadMessage(ctx context.Context, arg CreateThreadMessageParams) error {
	_, err := q.db.ExecContext(ctx, createThreadMessage,
		arg.ID,
		arg.ThreadID,
		arg.AuthorIdentity,
		arg.Content,
		arg.CreatedAt,
		arg.IsDelivered,
		arg.Actions,
	)
	return err
}

const ensureAuthorExists = `-- name: EnsureAuthorExists :exec
INSERT INTO authors (identity, alias) 
VALUES (?, ?)
ON CONFLICT (identity) DO NOTHING
`

type EnsureAuthorExistsParams struct {
	Identity string         `json:"identity"`
	Alias    sql.NullString `json:"alias"`
}

func (q *Queries) EnsureAuthorExists(ctx context.Context, arg EnsureAuthorExistsParams) error {
	_, err := q.db.ExecContext(ctx, ensureAuthorExists, arg.Identity, arg.Alias)
	return err
}

const getAuthor = `-- name: GetAuthor :one
SELECT identity, alias FROM authors WHERE identity = ?
`

func (q *Queries) GetAuthor(ctx context.Context, identity string) (Author, error) {
	row := q.db.QueryRowContext(ctx, getAuthor, identity)
	var i Author
	err := row.Scan(&i.Identity, &i.Alias)
	return i, err
}

const getHolonByIdentifier = `-- name: GetHolonByIdentifier :one
SELECT id FROM holons 
WHERE id = ? OR name = ? 
LIMIT 1
`

type GetHolonByIdentifierParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetHolonByIdentifier(ctx context.Context, arg GetHolonByIdentifierParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getHolonByIdentifier, arg.ID, arg.Name)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getThread = `-- name: GetThread :one
SELECT t.id, t.title, t.content, t.author_identity, t.created_at, t.expires_at, 
       t.image_urls, t.actions, t.views,
       a.identity, a.alias
FROM threads t
JOIN authors a ON t.author_identity = a.identity
WHERE t.id = ?
`

type GetThreadRow struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	AuthorIdentity string         `json:"authorIdentity"`
	CreatedAt      time.Time      `json:"createdAt"`
	ExpiresAt      sql.NullTime   `json:"expiresAt"`
	ImageUrls      interface{}    `json:"imageUrls"`
	Actions        interface{}    `json:"actions"`
	Views          int64          `json:"views"`
	Identity       string         `json:"identity"`
	Alias          sql.NullString `json:"alias"`
}

func (q *Queries) GetThread(ctx context.Context, id string) (GetThreadRow, error) {
	row := q.db.QueryRowContext(ctx, getThread, id)
	var i GetThreadRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.AuthorIdentity,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ImageUrls,
		&i.Actions,
		&i.Views,
		&i.Identity,
		&i.Alias,
	)
	return i, err
}

const getThreadMessage = `-- name: GetThreadMessage :one
SELECT tm.id, tm.thread_id, tm.author_identity, tm.content, tm.created_at, 
       tm.is_delivered, tm.actions,
       a.identity, a.alias
FROM thread_messages tm
JOIN authors a ON tm.author_identity = a.identity
WHERE tm.id = ?
`

type GetThreadMessageRow struct {
	ID             string         `json:"id"`
	ThreadID       string         `json:"threadId"`
	AuthorIdentity string         `json:"authorIdentity"`
	Content        string         `json:"content"`
	CreatedAt      time.Time      `json:"createdAt"`
	IsDelivered    bool           `json:"isDelivered"`
	Actions        interface{}    `json:"actions"`
	Identity       string         `json:"identity"`
	Alias          sql.NullString `json:"alias"`
}

func (q *Queries) GetThreadMessage(ctx context.Context, id string) (GetThreadMessageRow, error) {
	row := q.db.QueryRowContext(ctx, getThreadMessage, id)
	var i GetThreadMessageRow
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.AuthorIdentity,
		&i.Content,
		&i.CreatedAt,
		&i.IsDelivered,
		&i.Actions,
		&i.Identity,
		&i.Alias,
	)
	return i, err
}

const getThreadMessages = `-- name: GetThreadMessages :many
SELECT tm.id, tm.thread_id, tm.author_identity, tm.content, tm.created_at, 
       tm.is_delivered, tm.actions,
       a.identity, a.alias
FROM thread_messages tm
JOIN authors a ON tm.author_identity = a.identity
WHERE tm.thread_id = ?
ORDER BY tm.created_at ASC
`

type GetThreadMessagesRow struct {
	ID             string         `json:"id"`
	ThreadID       string         `json:"threadId"`
	AuthorIdentity string         `json:"authorIdentity"`
	Content        string         `json:"content"`
	CreatedAt      time.Time      `json:"createdAt"`
	IsDelivered    bool           `json:"isDelivered"`
	Actions        interface{}    `json:"actions"`
	Identity       string         `json:"identity"`
	Alias          sql.NullString `json:"alias"`
}

// Thread message queries
func (q *Queries) GetThreadMessages(ctx context.Context, threadID string) ([]GetThreadMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreadMessages, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadMessagesRow{}
	for rows.Next() {
		var i GetThreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.AuthorIdentity,
			&i.Content,
			&i.CreatedAt,
			&i.IsDelivered,
			&i.Actions,
			&i.Identity,
			&i.Alias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT t.id, t.title, t.content, t.author_identity, t.created_at, t.expires_at, 
       t.image_urls, t.actions, t.views,
       a.identity, a.alias
FROM threads t
JOIN authors a ON t.author_identity = a.identity
ORDER BY t.created_at DESC
LIMIT ? OFFSET ?
`

type GetThreadsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type GetThreadsRow struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	AuthorIdentity string         `json:"authorIdentity"`
	CreatedAt      time.Time      `json:"createdAt"`
	ExpiresAt      sql.NullTime   `json:"expiresAt"`
	ImageUrls      interface{}    `json:"imageUrls"`
	Actions        interface{}    `json:"actions"`
	Views          int64          `json:"views"`
	Identity       string         `json:"identity"`
	Alias          sql.NullString `json:"alias"`
}

// Thread queries
func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadsRow{}
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorIdentity,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.ImageUrls,
			&i.Actions,
			&i.Views,
			&i.Identity,
			&i.Alias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserHolons = `-- name: GetUserHolons :many
SELECT h.name 
FROM holons h
INNER JOIN holon_participants hp ON h.id = hp.holon_id
WHERE hp.author_identity = ?
ORDER BY h.name
`

// Holon queries
func (q *Queries) GetUserHolons(ctx context.Context, authorIdentity string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserHolons, authorIdentity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementThreadViews = `-- name: IncrementThreadViews :exec
UPDATE threads SET views = views + 1 WHERE id = ?
`

func (q *Queries) IncrementThreadViews(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, incrementThreadViews, id)
	return err
}
