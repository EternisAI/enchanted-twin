// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AgentTask struct {
	ID           string   `json:"id"`
	Name         string   `json:"name"`
	Schedule     string   `json:"schedule"`
	Plan         *string  `json:"plan,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	CompletedAt  *string  `json:"completedAt,omitempty"`
	TerminatedAt *string  `json:"terminatedAt,omitempty"`
	Output       *string  `json:"output,omitempty"`
	UpcomingRuns []string `json:"upcomingRuns"`
	PreviousRuns []string `json:"previousRuns"`
	Notify       bool     `json:"notify"`
}

type AppNotification struct {
	ID        string  `json:"id"`
	Title     string  `json:"title"`
	Message   string  `json:"message"`
	CreatedAt string  `json:"createdAt"`
	Image     *string `json:"image,omitempty"`
	Link      *string `json:"link,omitempty"`
}

type Author struct {
	Alias    *string `json:"alias,omitempty"`
	Identity string  `json:"identity"`
}

type Chat struct {
	ID              string       `json:"id"`
	Name            string       `json:"name"`
	Messages        []*Message   `json:"messages"`
	CreatedAt       string       `json:"createdAt"`
	Category        ChatCategory `json:"category"`
	HolonThreadID   *string      `json:"holonThreadId,omitempty"`
	InitialMessage  *string      `json:"initialMessage,omitempty"`
	PrivacyDictJSON *string      `json:"privacyDictJson,omitempty"`
}

type ChatSuggestionsCategory struct {
	Category    string   `json:"category"`
	Suggestions []string `json:"suggestions"`
}

type ConnectMCPServerInput struct {
	Name    string           `json:"name"`
	Command string           `json:"command"`
	Args    []string         `json:"args,omitempty"`
	Envs    []*KeyValueInput `json:"envs,omitempty"`
	Type    MCPServerType    `json:"type"`
}

type DataSource struct {
	ID            string `json:"id"`
	Name          string `json:"name"`
	Path          string `json:"path"`
	UpdatedAt     string `json:"updatedAt"`
	IsProcessed   bool   `json:"isProcessed"`
	IsIndexed     bool   `json:"isIndexed"`
	IndexProgress int32  `json:"indexProgress"`
	HasError      bool   `json:"hasError"`
}

type IndexingStatus struct {
	Status      IndexingState `json:"status"`
	DataSources []*DataSource `json:"dataSources"`
	Error       *string       `json:"error,omitempty"`
}

type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type KeyValueInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type MCPServer struct {
	ID        string        `json:"id"`
	Command   string        `json:"command"`
	Args      []string      `json:"args,omitempty"`
	Envs      []*KeyValue   `json:"envs,omitempty"`
	Name      string        `json:"name"`
	CreatedAt string        `json:"createdAt"`
	Enabled   bool          `json:"enabled"`
	Type      MCPServerType `json:"type"`
}

type MCPServerDefinition struct {
	ID        string        `json:"id"`
	Name      string        `json:"name"`
	Command   string        `json:"command"`
	Args      []string      `json:"args,omitempty"`
	Envs      []*KeyValue   `json:"envs,omitempty"`
	Type      MCPServerType `json:"type"`
	Connected bool          `json:"connected"`
	Enabled   bool          `json:"enabled"`
	Tools     []*Tool       `json:"tools,omitempty"`
}

type Message struct {
	ID          string      `json:"id"`
	Text        *string     `json:"text,omitempty"`
	ImageUrls   []string    `json:"imageUrls"`
	Role        Role        `json:"role"`
	ToolCalls   []*ToolCall `json:"toolCalls"`
	ToolResults []string    `json:"toolResults"`
	CreatedAt   string      `json:"createdAt"`
}

type MessageInput struct {
	Text string `json:"text"`
	Role Role   `json:"role"`
}

type MessageStreamPayload struct {
	MessageID  string   `json:"messageId"`
	Chunk      string   `json:"chunk"`
	Role       Role     `json:"role"`
	IsComplete bool     `json:"isComplete"`
	CreatedAt  *string  `json:"createdAt,omitempty"`
	ImageUrls  []string `json:"imageUrls"`
}

type Mutation struct {
}

type OAuthFlow struct {
	AuthURL     string `json:"authURL"`
	RedirectURI string `json:"redirectURI"`
}

type OAuthStatus struct {
	Provider  string   `json:"provider"`
	ExpiresAt string   `json:"expiresAt"`
	Scope     []string `json:"scope"`
	Username  string   `json:"username"`
	Error     bool     `json:"error"`
}

type Query struct {
}

type SetupProgress struct {
	Name     string  `json:"name"`
	Progress float64 `json:"progress"`
	Status   string  `json:"status"`
	Required bool    `json:"required"`
}

type StoreTokenInput struct {
	Token        string `json:"token"`
	RefreshToken string `json:"refreshToken"`
}

type Subscription struct {
}

type Thread struct {
	ID             string           `json:"id"`
	Title          string           `json:"title"`
	Content        string           `json:"content"`
	ImageURLs      []string         `json:"imageURLs"`
	Author         *Author          `json:"author"`
	CreatedAt      string           `json:"createdAt"`
	ExpiresAt      *string          `json:"expiresAt,omitempty"`
	Messages       []*ThreadMessage `json:"messages"`
	Actions        []string         `json:"actions,omitempty"`
	Views          int32            `json:"views"`
	RemoteThreadID *int32           `json:"remoteThreadId,omitempty"`
}

type ThreadMessage struct {
	ID          string   `json:"id"`
	Author      *Author  `json:"author"`
	Content     string   `json:"content"`
	CreatedAt   string   `json:"createdAt"`
	IsDelivered *bool    `json:"isDelivered,omitempty"`
	Actions     []string `json:"actions,omitempty"`
	State       string   `json:"state"`
}

type Tool struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type ToolCall struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	IsCompleted bool            `json:"isCompleted"`
	MessageID   string          `json:"messageId"`
	Result      *ToolCallResult `json:"result,omitempty"`
}

type ToolCallResult struct {
	Content   *string  `json:"content,omitempty"`
	ImageUrls []string `json:"imageUrls"`
}

type UpdateProfileInput struct {
	Name *string `json:"name,omitempty"`
	Bio  *string `json:"bio,omitempty"`
}

type UserProfile struct {
	Name                 *string         `json:"name,omitempty"`
	Bio                  *string         `json:"bio,omitempty"`
	IndexingStatus       *IndexingStatus `json:"indexingStatus,omitempty"`
	ConnectedDataSources []*DataSource   `json:"connectedDataSources"`
}

type WhatsAppQRCodeUpdate struct {
	QRCodeData  *string `json:"qrCodeData,omitempty"`
	Event       string  `json:"event"`
	Timestamp   string  `json:"timestamp"`
	IsConnected bool    `json:"isConnected"`
}

type WhatsAppStatus struct {
	IsConnected   bool    `json:"isConnected"`
	QRCodeData    *string `json:"qrCodeData,omitempty"`
	StatusMessage string  `json:"statusMessage"`
}

type WhatsAppSyncStatus struct {
	IsSyncing     bool    `json:"isSyncing"`
	IsCompleted   bool    `json:"isCompleted"`
	Error         *string `json:"error,omitempty"`
	StatusMessage *string `json:"statusMessage,omitempty"`
}

type ChatCategory string

const (
	ChatCategoryText  ChatCategory = "TEXT"
	ChatCategoryVoice ChatCategory = "VOICE"
	ChatCategoryHolon ChatCategory = "HOLON"
)

var AllChatCategory = []ChatCategory{
	ChatCategoryText,
	ChatCategoryVoice,
	ChatCategoryHolon,
}

func (e ChatCategory) IsValid() bool {
	switch e {
	case ChatCategoryText, ChatCategoryVoice, ChatCategoryHolon:
		return true
	}
	return false
}

func (e ChatCategory) String() string {
	return string(e)
}

func (e *ChatCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatCategory", str)
	}
	return nil
}

func (e ChatCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChatCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChatCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IndexingState string

const (
	IndexingStateNotStarted       IndexingState = "NOT_STARTED"
	IndexingStateDownloadingModel IndexingState = "DOWNLOADING_MODEL"
	IndexingStateProcessingData   IndexingState = "PROCESSING_DATA"
	IndexingStateIndexingData     IndexingState = "INDEXING_DATA"
	IndexingStateCompleted        IndexingState = "COMPLETED"
	IndexingStateFailed           IndexingState = "FAILED"
)

var AllIndexingState = []IndexingState{
	IndexingStateNotStarted,
	IndexingStateDownloadingModel,
	IndexingStateProcessingData,
	IndexingStateIndexingData,
	IndexingStateCompleted,
	IndexingStateFailed,
}

func (e IndexingState) IsValid() bool {
	switch e {
	case IndexingStateNotStarted, IndexingStateDownloadingModel, IndexingStateProcessingData, IndexingStateIndexingData, IndexingStateCompleted, IndexingStateFailed:
		return true
	}
	return false
}

func (e IndexingState) String() string {
	return string(e)
}

func (e *IndexingState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IndexingState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IndexingState", str)
	}
	return nil
}

func (e IndexingState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IndexingState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IndexingState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MCPServerType string

const (
	MCPServerTypeTwitter    MCPServerType = "TWITTER"
	MCPServerTypeGoogle     MCPServerType = "GOOGLE"
	MCPServerTypeSLACk      MCPServerType = "SLACK"
	MCPServerTypeOther      MCPServerType = "OTHER"
	MCPServerTypeScreenpipe MCPServerType = "SCREENPIPE"
	MCPServerTypeEnchanted  MCPServerType = "ENCHANTED"
)

var AllMCPServerType = []MCPServerType{
	MCPServerTypeTwitter,
	MCPServerTypeGoogle,
	MCPServerTypeSLACk,
	MCPServerTypeOther,
	MCPServerTypeScreenpipe,
	MCPServerTypeEnchanted,
}

func (e MCPServerType) IsValid() bool {
	switch e {
	case MCPServerTypeTwitter, MCPServerTypeGoogle, MCPServerTypeSLACk, MCPServerTypeOther, MCPServerTypeScreenpipe, MCPServerTypeEnchanted:
		return true
	}
	return false
}

func (e MCPServerType) String() string {
	return string(e)
}

func (e *MCPServerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MCPServerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MCPServerType", str)
	}
	return nil
}

func (e MCPServerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MCPServerType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MCPServerType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Role string

const (
	RoleUser      Role = "USER"
	RoleAssistant Role = "ASSISTANT"
)

var AllRole = []Role{
	RoleUser,
	RoleAssistant,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleUser, RoleAssistant:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Role) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Role) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
