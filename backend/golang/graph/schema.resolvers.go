package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/EternisAI/enchanted-twin/graph/model"
	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
	"go.temporal.io/sdk/client"
)

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *model.Chat) ([]*model.Message, error) {
	return r.TwinChatService.GetMessagesByChatId(ctx, obj.ID)
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (bool, error) {
	// Use SQLite for profile updates
	return r.Store.UpdateUserProfile(ctx, input)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, name string) (*model.Chat, error) {
	chat, err := r.TwinChatService.CreateChat(ctx, name)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, text string) (*model.Message, error) {
	subject := fmt.Sprintf("chat.%s", chatID)

	userMessageJson, err := json.Marshal(model.Message{
		ID:        uuid.New().String(),
		Text:      &text,
		CreatedAt: time.Now().Format(time.RFC3339),
		Role:      model.RoleUser,
	})
	if err != nil {
		return nil, err
	}
	err = r.Nc.Publish(subject, userMessageJson)
	if err != nil {
		return nil, err
	}

	return r.TwinChatService.SendMessage(ctx, chatID, text)
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, chatID string) (*model.Chat, error) {
	panic(fmt.Errorf("not implemented: DeleteChat - deleteChat"))
}

// StartIndexing is the resolver for the startIndexing field.
func (r *mutationResolver) StartIndexing(ctx context.Context) (bool, error) {
	options := client.StartWorkflowOptions{
		ID:        "index",
		TaskQueue: "default",
	}
	_, err := (r.TemporalClient).ExecuteWorkflow(ctx, options, "IndexWorkflow", map[string]interface{}{})
	if err != nil {
		return false, fmt.Errorf("error executing workflow: %v", err)
	}

	return true, nil
}

// AddDataSource is the resolver for the addDataSource field.
func (r *mutationResolver) AddDataSource(ctx context.Context, name string, path string) (bool, error) {
	_, err := r.Store.CreateDataSource(ctx, uuid.New().String(), name, path)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteDataSource is the resolver for the deleteDataSource field.
func (r *mutationResolver) DeleteDataSource(ctx context.Context, id string) (bool, error) {
	result, err := r.Store.DeleteDataSourceError(ctx, id)
	if err != nil {
		return false, err
	}

	return result != nil, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*model.UserProfile, error) {
	if r.Store == nil {
		panic("Store not initialized")
	}

	profile, err := r.Store.GetUserProfile(ctx)
	if err != nil {
		return nil, err
	}

	workflowID := "index"
	workflowRunID := "" // Empty string means latest run
	var stateQuery model.IndexingState
	encodedValue, err := r.TemporalClient.QueryWorkflow(ctx, workflowID, workflowRunID, "getIndexingState")
	if err != nil {
		fmt.Println(err)
		return profile, nil
	}

	if err := encodedValue.Get(&stateQuery); err != nil {
		fmt.Println(err)
		return profile, nil
	}

	profile.IndexingStatus = &model.IndexingStatus{
		Status:                 stateQuery,
		ProcessingDataProgress: 0,
		IndexingDataProgress:   0,
	}

	return profile, nil
}

// GetChats is the resolver for the getChats field.
func (r *queryResolver) GetChats(ctx context.Context, first int32, offset int32) ([]*model.Chat, error) {
	chats, err := r.TwinChatService.GetChats(ctx)
	if err != nil {
		return nil, err
	}
	return chats, nil
}

// GetChat is the resolver for the getChat field.
func (r *queryResolver) GetChat(ctx context.Context, id string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, id)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// GetDataSources is the resolver for the getDataSources field.
func (r *queryResolver) GetDataSources(ctx context.Context) ([]*model.DataSource, error) {
	dbDataSources, err := r.Store.GetDataSources(ctx)
	if err != nil {
		return nil, err
	}

	modelDataSources := make([]*model.DataSource, len(dbDataSources))
	for i, ds := range dbDataSources {
		modelDataSources[i] = &model.DataSource{
			ID:        ds.ID,
			Name:      ds.Name,
			Path:      ds.Path,
			UpdatedAt: ds.UpdatedAt,
			IsIndexed: ds.IsIndexed != nil && *ds.IsIndexed,
		}
	}
	return modelDataSources, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	messages := make(chan *model.Message)
	subject := fmt.Sprintf("chat.%s", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var message model.Message
		err := json.Unmarshal(msg.Data, &message)
		if err != nil {
			r.Logger.Info("unmarshal error", "Error parsing message: %v", err)
			return
		}

		messages <- &message
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(messages)
	}()

	return messages, nil
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *subscriptionResolver) IndexingStatus(ctx context.Context) (<-chan *model.IndexingStatus, error) {
	if r.Nc == nil {
		return nil, errors.New("NATS connection is nil")
	}

	if !r.Nc.IsConnected() {
		return nil, errors.New("NATS connection is not connected")
	}

	r.Logger.Info("Subscribing to indexing status",
		"connected", r.Nc.IsConnected(),
		"status", r.Nc.Status().String())

	statusChan := make(chan *model.IndexingStatus, 100)
	subject := "indexing_data"

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		r.Logger.Info("Received indexing status message",
			"subject", msg.Subject,
			"data", string(msg.Data),
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())

		var status model.IndexingStatus
		err := json.Unmarshal(msg.Data, &status)
		if err != nil {
			r.Logger.Error("Failed to unmarshal indexing status",
				"error", err,
				"data", string(msg.Data))
			return
		}

		select {
		case statusChan <- &status:
			r.Logger.Info("Successfully sent status to channel", "subject", msg.Subject)
		case <-ctx.Done():
			r.Logger.Info("Context cancelled while sending status", "subject", msg.Subject)
			return
		default:
			r.Logger.Warn("Status channel is full, dropping message", "subject", msg.Subject)
		}
	})
	if err != nil {
		r.Logger.Error("Failed to subscribe to indexing status",
			"error", err,
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		return nil, err
	}

	go func() {
		<-ctx.Done()
		r.Logger.Info("Unsubscribing from indexing status",
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		if err := sub.Unsubscribe(); err != nil {
			r.Logger.Error("Error unsubscribing", "error", err)
		}
		close(statusChan)
	}()

	return statusChan, nil
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type (
	chatResolver         struct{ *Resolver }
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
)
