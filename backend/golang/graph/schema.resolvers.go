package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
	"go.temporal.io/sdk/client"

	"github.com/EternisAI/enchanted-twin/graph/model"
	planned "github.com/EternisAI/enchanted-twin/pkg/agent/planned-v2"
	"github.com/EternisAI/enchanted-twin/pkg/auth"
	"github.com/EternisAI/enchanted-twin/pkg/dataprocessing/workflows"
	"github.com/EternisAI/enchanted-twin/pkg/helpers"
	"github.com/EternisAI/enchanted-twin/pkg/telegram"
)

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *model.Chat) ([]*model.Message, error) {
	return r.TwinChatService.GetMessagesByChatId(ctx, obj.ID)
}

// StartOAuthFlow is the resolver for the startOAuthFlow field.
func (r *mutationResolver) StartOAuthFlow(ctx context.Context, provider string, scope string) (*model.OAuthFlow, error) {
	auth, redir, err := auth.StartOAuthFlow(ctx, r.Logger, r.Store, provider, scope)
	return &model.OAuthFlow{
		AuthURL:     auth,
		RedirectURI: redir,
	}, err
}

// CompleteOAuthFlow is the resolver for the completeOAuthFlow field.
func (r *mutationResolver) CompleteOAuthFlow(ctx context.Context, state string, authCode string) (string, error) {
	result, username, err := auth.CompleteOAuthFlow(ctx, r.Logger, r.Store, state, authCode)
	if err != nil {
		return "", err
	}

	switch result {
	case "twitter":
		_, err = r.MCPService.ConnectMCPServer(ctx, model.ConnectMCPServerInput{
			Name:    "Twitter",
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeTwitter,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Twitter server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"refresh-twitter-token",
			time.Minute*30,
			auth.TokenRefreshWorkflow,
			[]any{auth.TokenRefreshWorkflowInput{Provider: "twitter"}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"x-sync-schedule",
			time.Minute*10,
			"XSyncWorkflow",
			[]any{workflows.XSyncWorkflowInput{Username: username}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

	case "google":
		_, err = r.MCPService.ConnectMCPServer(ctx, model.ConnectMCPServerInput{
			Name:    "Google",
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeGoogle,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Google server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"refresh-gmail-token",
			time.Minute*30,
			auth.TokenRefreshWorkflow,
			[]any{auth.TokenRefreshWorkflowInput{Provider: "google"}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"gmail-sync-schedule",
			time.Minute*2,
			"GmailSyncWorkflow",
			[]any{workflows.GmailSyncWorkflowInput{Username: username}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

	case "slack":
		_, err = r.MCPService.ConnectMCPServer(ctx, model.ConnectMCPServerInput{
			Name:    "Slack",
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeSLACk,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Slack server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"slack-sync-schedule",
			time.Minute*2,
			"SlackSyncWorkflow",
			[]any{},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}
	default:
		// Nothing to do
	}

	return result, err
}

// RefreshExpiredOAuthTokens is the resolver for the refreshExpiredOAuthTokens field.
func (r *mutationResolver) RefreshExpiredOAuthTokens(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := auth.RefreshExpiredTokens(ctx, r.Logger, r.Store)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (bool, error) {
	// Use SQLite for profile updates
	return r.Store.UpdateUserProfile(ctx, input)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, name string) (*model.Chat, error) {
	chat, err := r.TwinChatService.CreateChat(ctx, name)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, text string) (*model.Message, error) {
	subject := fmt.Sprintf("chat.%s", chatID)

	userMessageJson, err := json.Marshal(model.Message{
		ID:        uuid.New().String(),
		Text:      &text,
		CreatedAt: time.Now().Format(time.RFC3339),
		Role:      model.RoleUser,
	})
	if err != nil {
		return nil, err
	}
	err = r.Nc.Publish(subject, userMessageJson)
	if err != nil {
		return nil, err
	}

	return r.TwinChatService.SendMessage(ctx, chatID, text)
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, chatID string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, chatID)
	if err != nil {
		return nil, fmt.Errorf("chat not found")
	}

	err = r.TwinChatService.DeleteChat(ctx, chatID)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// StartIndexing is the resolver for the startIndexing field.
func (r *mutationResolver) StartIndexing(ctx context.Context) (bool, error) {
	options := client.StartWorkflowOptions{
		ID:        "index",
		TaskQueue: "default",
	}
	_, err := (r.TemporalClient).ExecuteWorkflow(
		ctx,
		options,
		"InitializeWorkflow",
		map[string]interface{}{},
	)
	if err != nil {
		return false, fmt.Errorf("error executing workflow: %v", err)
	}

	return true, nil
}

// AddDataSource is the resolver for the addDataSource field.
func (r *mutationResolver) AddDataSource(ctx context.Context, name string, path string) (bool, error) {
	_, err := r.Store.CreateDataSource(ctx, uuid.New().String(), name, path)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteDataSource is the resolver for the deleteDataSource field.
func (r *mutationResolver) DeleteDataSource(ctx context.Context, id string) (bool, error) {
	result, err := r.Store.DeleteDataSource(ctx, id)
	if err != nil {
		return false, err
	}

	return result != nil, nil
}

// ConnectMCPServer is the resolver for the connectMCPServer field.
func (r *mutationResolver) ConnectMCPServer(ctx context.Context, input model.ConnectMCPServerInput) (bool, error) {
	_, err := r.MCPService.ConnectMCPServer(ctx, input)
	if err != nil {
		return false, err
	}
	return true, nil
}

// SendTelegramMessage is the resolver for the sendTelegramMessage field.
func (r *mutationResolver) SendTelegramMessage(ctx context.Context, chatUUID string, text string) (bool, error) {
	chatID, err := r.TelegramService.GetChatIDFromChatUUID(ctx, chatUUID)
	if err != nil || chatID == "" {
		return false, fmt.Errorf("failed to get telegram chat ID: %w", err)
	}

	err = r.TelegramService.SendMessage(ctx, chatID, text)
	if err != nil {
		return false, fmt.Errorf("failed to send telegram message: %w", err)
	}

	return true, nil
}

// DeleteAgentTask is the resolver for the deleteAgentTask field.
func (r *mutationResolver) DeleteAgentTask(ctx context.Context, id string) (bool, error) {
	runID := id

	// Use the RootClient to properly terminate the workflow and update state
	if r.RootClient != nil {
		// Call our new method that handles both termination and state cleanup
		cmdID, err := r.RootClient.TerminateChildWorkflow(ctx, runID, "Deleted via GraphQL API")
		if err != nil {
			r.Logger.Error("Failed to terminate workflow", "error", err, "workflowID", id)
			return false, fmt.Errorf("failed to delete agent task: %w", err)
		}

		r.Logger.Info("Successfully terminated workflow", "workflowID", id, "commandID", cmdID)
		return true, nil
	} else {
		// Fallback to direct Temporal client if RootClient is not available
		r.Logger.Warn("RootClient not available, falling back to direct termination", "workflowID", id)

		// Create a Temporal client to interact with the workflow
		c := r.TemporalClient

		// Try to terminate the workflow by ID
		err := c.TerminateWorkflow(ctx, id, "", "Deleted via GraphQL API")
		if err != nil {
			r.Logger.Error("Failed to terminate workflow", "error", err, "workflowID", id)
			return false, fmt.Errorf("failed to delete agent task: %w", err)
		}

		r.Logger.Info("Successfully terminated workflow but state may not be updated in root workflow",
			"workflowID", id)
		return true, nil
	}
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*model.UserProfile, error) {
	if r.Store == nil {
		panic("Store not initialized")
	}

	profile, err := r.Store.GetUserProfile(ctx)
	if err != nil {
		return nil, err
	}

	return profile, nil
}

// GetChats is the resolver for the getChats field.
func (r *queryResolver) GetChats(ctx context.Context, first int32, offset int32) ([]*model.Chat, error) {
	chats, err := r.TwinChatService.GetChats(ctx)
	if err != nil {
		return nil, err
	}
	return chats, nil
}

// GetChat is the resolver for the getChat field.
func (r *queryResolver) GetChat(ctx context.Context, id string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, id)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// GetDataSources is the resolver for the getDataSources field.
func (r *queryResolver) GetDataSources(ctx context.Context) ([]*model.DataSource, error) {
	dbDataSources, err := r.Store.GetDataSources(ctx)
	if err != nil {
		return nil, err
	}

	modelDataSources := make([]*model.DataSource, len(dbDataSources))
	for i, ds := range dbDataSources {
		modelDataSources[i] = &model.DataSource{
			ID:        ds.ID,
			Name:      ds.Name,
			Path:      ds.Path,
			UpdatedAt: ds.UpdatedAt,
			IsIndexed: ds.IsIndexed != nil && *ds.IsIndexed,
		}
	}
	return modelDataSources, nil
}

// GetOAuthStatus is the resolver for the getOAuthStatus field.
func (r *queryResolver) GetOAuthStatus(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := r.Store.GetOAuthStatus(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// GetChatSuggestions is the resolver for the getChatSuggestions field.
func (r *queryResolver) GetChatSuggestions(ctx context.Context, chatID string) ([]*model.ChatSuggestionsCategory, error) {
	return r.TwinChatService.GetChatSuggestions(ctx, chatID)
}

// GetMCPServers is the resolver for the getMCPServers field.
func (r *queryResolver) GetMCPServers(ctx context.Context) ([]*model.MCPServerDefinition, error) {
	return r.MCPService.GetMCPServers(ctx)
}

// GetTools is the resolver for the getTools field.
func (r *queryResolver) GetTools(ctx context.Context) ([]*model.Tool, error) {
	tools, err := r.MCPService.GetTools(ctx)
	if err != nil {
		return nil, err
	}

	toolsDefinitions := make([]*model.Tool, len(tools))
	for i, tool := range tools {
		toolsDefinitions[i] = &model.Tool{
			Name:        tool.Name,
			Description: *tool.Description,
		}
	}
	return toolsDefinitions, nil
}

// GetAgentTasks is the resolver for the getAgentTasks field.
func (r *queryResolver) GetAgentTasks(ctx context.Context) ([]*model.AgentTask, error) {
	tc := r.TemporalClient
	rc := r.RootClient

	runs, err := rc.ListWorkflows(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list active runs: %w", err)
	}
	r.Logger.Debug("active runs", "count", len(runs))

	tasks := make([]*model.AgentTask, 0, len(runs))
	for _, run := range runs {
		// TODO: below as func GetState() to plannedv2 or baseagent
		r.Logger.Debug("querying workflow", "workflow_id", run.WorkflowID, "run_id", run.RunID)
		queryRes, err := tc.QueryWorkflow(
			ctx,
			run.WorkflowID,
			run.RunID,
			planned.QueryGetState,
		)
		if err != nil {
			r.Logger.Warn("failed to query workflow", "error", err)
			continue
		}
		var state planned.PlanState
		if err := queryRes.Get(&state); err != nil {
			r.Logger.Warn("failed to get workflow state", "error", err)
			continue
		}

		updatedAt := run.CreatedAt
		if len(state.History) > 0 {
			updatedAt = state.History[len(state.History)-1].Timestamp
		}

		tasks = append(tasks, &model.AgentTask{
			ID:        run.RunID,
			Name:      state.Name,
			Schedule:  state.Schedule,
			Plan:      &state.Plan,
			CreatedAt: run.CreatedAt.String(),
			UpdatedAt: updatedAt.String(),
		})
	}

	return tasks, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	messages := make(chan *model.Message)
	subject := fmt.Sprintf("chat.%s", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var message model.Message
		err := json.Unmarshal(msg.Data, &message)
		if err != nil {
			r.Logger.Info("unmarshal error", "Error parsing message: %v", err)
			return
		}

		messages <- &message
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(messages)
	}()

	return messages, nil
}

// ToolCallUpdated is the resolver for the toolCallUpdated field.
func (r *subscriptionResolver) ToolCallUpdated(ctx context.Context, chatID string) (<-chan *model.ToolCall, error) {
	toolCalls := make(chan *model.ToolCall)
	subject := fmt.Sprintf("chat.%s.tool_call", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var toolCall model.ToolCall
		err := json.Unmarshal(msg.Data, &toolCall)
		if err != nil {
			r.Logger.Info("unmarshal error", "Error parsing message: %v", err)
			return
		}

		toolCalls <- &toolCall
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(toolCalls)
	}()

	return toolCalls, nil
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *subscriptionResolver) IndexingStatus(ctx context.Context) (<-chan *model.IndexingStatus, error) {
	if r.Nc == nil {
		return nil, errors.New("NATS connection is nil")
	}

	if !r.Nc.IsConnected() {
		return nil, errors.New("NATS connection is not connected")
	}

	r.Logger.Info("Subscribing to indexing status",
		"connected", r.Nc.IsConnected(),
		"status", r.Nc.Status().String())

	statusChan := make(chan *model.IndexingStatus, 100)
	subject := "indexing_data"

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var status model.IndexingStatus
		err := json.Unmarshal(msg.Data, &status)
		if err != nil {
			r.Logger.Error("Failed to unmarshal indexing status",
				"error", err,
				"data", string(msg.Data))
			return
		}

		select {
		case statusChan <- &status:
		case <-ctx.Done():
			r.Logger.Info("Context canceled while sending status", "subject", msg.Subject)
			return
		default:
			r.Logger.Warn("Status channel is full, dropping message", "subject", msg.Subject)
		}
	})
	if err != nil {
		r.Logger.Error("Failed to subscribe to indexing status",
			"error", err,
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		return nil, err
	}

	go func() {
		<-ctx.Done()
		r.Logger.Info("Unsubscribing from indexing status",
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		if err := sub.Unsubscribe(); err != nil {
			r.Logger.Error("Error unsubscribing", "error", err)
		}
		close(statusChan)
	}()

	return statusChan, nil
}

// NotificationAdded is the resolver for the notificationAdded field.
func (r *subscriptionResolver) NotificationAdded(ctx context.Context) (<-chan *model.AppNotification, error) {
	notificationChan := make(chan *model.AppNotification, 10)

	go func() {
		defer close(notificationChan)

		// Create 3 notifications with 5 second delay between each
		for i := 1; i <= 3; i++ {
			select {
			case <-ctx.Done():
				r.Logger.Info("Context canceled while sending notifications")
				return
			case <-time.After(5 * time.Second):
				notification := &model.AppNotification{
					ID:        fmt.Sprintf("notification-%d", i),
					Title:     fmt.Sprintf("Notification %d", i),
					Message:   fmt.Sprintf("This is notification number %d", i),
					CreatedAt: time.Now().Format(time.RFC3339),
				}

				select {
				case notificationChan <- notification:
					r.Logger.Info("Sent notification", "id", notification.ID)
				case <-ctx.Done():
					r.Logger.Info("Context canceled while sending notification", "id", notification.ID)
					return
				}
			}
		}
	}()

	return notificationChan, nil
}

// TelegramMessageAdded is the resolver for the telegramMessageAdded field.
func (r *subscriptionResolver) TelegramMessageAdded(ctx context.Context, chatUUID string) (<-chan *model.Message, error) {
	if r.Nc == nil {
		return nil, errors.New("NATS connection is not initialized")
	}
	chatID, err := r.TelegramService.GetChatIDFromChatUUID(ctx, chatUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get telegram chat ID: %w", err)
	}

	messages := make(chan *model.Message, 100) // Add buffer to prevent blocking

	subject := fmt.Sprintf("telegram.chat.%s", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		if msg == nil || msg.Data == nil {
			r.Logger.Error("Received nil message or data")
			return
		}

		var telegramMessage telegram.Message
		if err := json.Unmarshal(msg.Data, &telegramMessage); err != nil {
			r.Logger.Error("Failed to unmarshal Telegram message", "error", err)
			return
		}

		// Convert Telegram message to GraphQL message model
		text := telegramMessage.Text
		message := &model.Message{
			ID:          strconv.Itoa(telegramMessage.MessageID),
			Text:        &text,
			CreatedAt:   time.Unix(int64(telegramMessage.Date), 0).Format(time.RFC3339),
			Role:        model.RoleUser,
			ImageUrls:   []string{},
			ToolCalls:   []*model.ToolCall{},
			ToolResults: []string{},
		}

		select {
		case messages <- message:
			r.Logger.Info("Sent message to channel", "chat_id", chatID)
		case <-ctx.Done():
			r.Logger.Info("Context canceled while sending message", "chat_id", chatID)
			return
		default:
			r.Logger.Warn("Message channel is full, dropping message", "chat_id", chatID)
		}
	})
	if err != nil {
		close(messages)
		return nil, fmt.Errorf("failed to subscribe to NATS subject: %w", err)
	}

	go func() {
		<-ctx.Done()
		if err := sub.Unsubscribe(); err != nil {
			r.Logger.Error("Error unsubscribing from NATS", "error", err)
		}
		close(messages)
	}()

	return messages, nil
}

// MessageStream is the resolver for the messageStream subscription.
func (r *subscriptionResolver) MessageStream(ctx context.Context, chatID string) (<-chan *model.MessageStreamPayload, error) {
	subject := fmt.Sprintf("chat.%s.stream", chatID)
	ch := make(chan *model.MessageStreamPayload, 12) // small buffer

	sub, err := r.Nc.Subscribe(subject, func(m *nats.Msg) {
		var p model.MessageStreamPayload
		if err := json.Unmarshal(m.Data, &p); err != nil {
			r.Logger.Warn("stream unmarshal error", "err", err)
			return
		}
		ch <- &p
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(ch)
	}()

	return ch, nil
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *userProfileResolver) IndexingStatus(ctx context.Context, obj *model.UserProfile) (*model.IndexingStatus, error) {
	workflowID := "index"
	workflowRunID := "" // Empty string means latest run
	var stateQuery model.IndexingState
	encodedValue, err := r.TemporalClient.QueryWorkflow(
		ctx,
		workflowID,
		workflowRunID,
		"getIndexingState",
	)
	if err != nil {
		r.Logger.Error("Error querying workflow", "error", err)
		return nil, nil
	}

	if err := encodedValue.Get(&stateQuery); err != nil {
		r.Logger.Error("Error querying workflow", "error", err)
		return nil, nil
	}

	return &model.IndexingStatus{
		Status: stateQuery,
	}, nil
}

// ConnectedDataSources is the resolver for the connectedDataSources field.
func (r *userProfileResolver) ConnectedDataSources(ctx context.Context, obj *model.UserProfile) ([]*model.DataSource, error) {
	panic(fmt.Errorf("not implemented: ConnectedDataSources - connectedDataSources"))
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// UserProfile returns UserProfileResolver implementation.
func (r *Resolver) UserProfile() UserProfileResolver { return &userProfileResolver{r} }

type (
	chatResolver         struct{ *Resolver }
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
	userProfileResolver  struct{ *Resolver }
)
