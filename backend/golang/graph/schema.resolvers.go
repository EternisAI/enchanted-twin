package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/lnquy/cron"
	nats "github.com/nats-io/nats.go"
	common "go.temporal.io/api/common/v1"
	"go.temporal.io/sdk/client"

	"github.com/EternisAI/enchanted-twin/graph/model"
	"github.com/EternisAI/enchanted-twin/pkg/agent/scheduler"
	"github.com/EternisAI/enchanted-twin/pkg/auth"
	"github.com/EternisAI/enchanted-twin/pkg/dataprocessing/workflows"
	"github.com/EternisAI/enchanted-twin/pkg/db"
	"github.com/EternisAI/enchanted-twin/pkg/helpers"
	"github.com/EternisAI/enchanted-twin/pkg/whatsapp"
)

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *model.Chat) ([]*model.Message, error) {
	return r.TwinChatService.GetMessagesByChatId(ctx, obj.ID)
}

// StartOAuthFlow is the resolver for the startOAuthFlow field.
func (r *mutationResolver) StartOAuthFlow(ctx context.Context, provider string, scope string) (*model.OAuthFlow, error) {
	auth, redir, err := auth.StartOAuthFlow(ctx, r.Logger, r.Store, provider, scope)
	return &model.OAuthFlow{
		AuthURL:     auth,
		RedirectURI: redir,
	}, err
}

// CompleteOAuthFlow is the resolver for the completeOAuthFlow field.
func (r *mutationResolver) CompleteOAuthFlow(ctx context.Context, state string, authCode string) (string, error) {
	result, username, err := auth.CompleteOAuthFlow(ctx, r.Logger, r.Store, state, authCode)
	if err != nil {
		return "", err
	}

	switch result {
	case "twitter":
		_, err = r.MCPService.ConnectMCPServerIfNotExists(ctx, model.ConnectMCPServerInput{
			Name:    model.MCPServerTypeTwitter.String(),
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeTwitter,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Twitter server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"refresh-twitter-token",
			time.Minute*30,
			auth.TokenRefreshWorkflow,
			[]any{auth.TokenRefreshWorkflowInput{Provider: "twitter"}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"x-sync-schedule",
			time.Minute*10,
			"XSyncWorkflow",
			[]any{workflows.XSyncWorkflowInput{Username: username}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

	case "google":
		// Remote authentication is now handled automatically by the holon service
		// when it's initialized, so we don't need to do it here anymore

		_, err = r.MCPService.ConnectMCPServerIfNotExists(ctx, model.ConnectMCPServerInput{
			Name:    model.MCPServerTypeGoogle.String(),
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeGoogle,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Google server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"refresh-gmail-token",
			time.Minute*30,
			auth.TokenRefreshWorkflow,
			[]any{auth.TokenRefreshWorkflowInput{Provider: "google"}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"gmail-sync-schedule",
			time.Minute*2,
			"GmailSyncWorkflow",
			[]any{workflows.GmailSyncWorkflowInput{Username: username}},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

		options := client.StartWorkflowOptions{
			ID:        "gmail-history-workflow",
			TaskQueue: "default",
		}
		input := workflows.GmailHistoryWorkflowInput{
			Username: username,
		}

		_, err = (r.TemporalClient).ExecuteWorkflow(
			ctx,
			options,
			"GmailHistoryWorkflow",
			input,
		)
		if err != nil {
			return "", fmt.Errorf("error executing workflow: %v", err)
		}

	case "slack":
		_, err = r.MCPService.ConnectMCPServerIfNotExists(ctx, model.ConnectMCPServerInput{
			Name:    model.MCPServerTypeSLACk.String(),
			Command: "npx",
			Args:    []string{},
			Envs:    []*model.KeyValueInput{},
			Type:    model.MCPServerTypeSLACk,
		})
		if err != nil {
			return "", fmt.Errorf("oauth successful but failed to create Slack server: %w", err)
		}

		err = helpers.CreateScheduleIfNotExists(
			r.Logger,
			r.TemporalClient,
			"slack-sync-schedule",
			time.Minute*2,
			"SlackSyncWorkflow",
			[]any{},
		)
		if err != nil {
			r.Logger.Error("Error creating schedule", "error", err)
			return "", err
		}

	default:
		// Nothing to do
	}

	return result, err
}

// RefreshExpiredOAuthTokens is the resolver for the refreshExpiredOAuthTokens field.
func (r *mutationResolver) RefreshExpiredOAuthTokens(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := auth.RefreshExpiredTokens(ctx, r.Logger, r.Store)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (bool, error) {
	// Use SQLite for profile updates
	return r.Store.UpdateUserProfile(ctx, input)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, name string, category model.ChatCategory, holonThreadID *string, initialMessage *string) (*model.Chat, error) {
	chat, err := r.TwinChatService.CreateChat(ctx, name, category, holonThreadID)
	if err != nil {
		r.Logger.Error("Failed to create chat", "error", err)
		return nil, err
	}

	if initialMessage != nil && *initialMessage != "" {
		go func() {
			bgCtx := context.Background()

			isVoice := category == model.ChatCategoryVoice
			_, err := r.TwinChatService.SendMessage(bgCtx, chat.ID, *initialMessage, false, isVoice)
			if err != nil {
				r.Logger.Error("Failed to send initial message asynchronously", "error", err, "chat_id", chat.ID)

				errorMsg := map[string]interface{}{
					"type":    "error",
					"message": "Failed to send initial message",
					"chatId":  chat.ID,
				}
				if errorData, marshalErr := json.Marshal(errorMsg); marshalErr == nil {
					err := r.Nc.Publish(fmt.Sprintf("chat.%s.error", chat.ID), errorData)
					if err != nil {
						r.Logger.Error("Failed to publish error message", "error", err, "chat_id", chat.ID)
					}
				}
			}
		}()
	}

	return &chat, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, text string, reasoning bool, voice bool) (*model.Message, error) {
	return r.TwinChatService.SendMessage(context.WithoutCancel(ctx), chatID, text, reasoning, voice)
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, chatID string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, chatID)
	if err != nil {
		return nil, fmt.Errorf("chat not found")
	}

	err = r.TwinChatService.DeleteChat(ctx, chatID)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// StartIndexing is the resolver for the startIndexing field.
func (r *mutationResolver) StartIndexing(ctx context.Context) (bool, error) {
	options := client.StartWorkflowOptions{
		ID:        "index",
		TaskQueue: "default",
	}
	_, err := (r.TemporalClient).ExecuteWorkflow(
		ctx,
		options,
		"InitializeWorkflow",
		map[string]any{},
	)
	if err != nil {
		return false, fmt.Errorf("error executing workflow: %v", err)
	}

	return true, nil
}

// AddDataSource is the resolver for the addDataSource field.
func (r *mutationResolver) AddDataSource(ctx context.Context, name string, path string) (bool, error) {
	_, err := r.Store.CreateDataSource(ctx, uuid.New().String(), name, path)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteDataSource is the resolver for the deleteDataSource field.
func (r *mutationResolver) DeleteDataSource(ctx context.Context, id string) (bool, error) {
	result, err := r.Store.DeleteDataSource(ctx, id)
	if err != nil {
		return false, err
	}

	return result != nil, nil
}

// ConnectMCPServer is the resolver for the connectMCPServer field.
func (r *mutationResolver) ConnectMCPServer(ctx context.Context, input model.ConnectMCPServerInput) (bool, error) {
	_, err := r.MCPService.ConnectMCPServer(ctx, input)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteAgentTask is the resolver for the deleteAgentTask field.
func (r *mutationResolver) DeleteAgentTask(ctx context.Context, id string) (bool, error) {
	handle := r.TemporalClient.ScheduleClient().GetHandle(ctx, id)

	if handle == nil {
		return false, fmt.Errorf("agent task not found")
	}

	err := handle.Delete(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateAgentTask sets the Notify flag for the given schedule.
func (r *mutationResolver) UpdateAgentTask(ctx context.Context, id string, notify bool) (bool, error) {
	h := r.TemporalClient.ScheduleClient().GetHandle(ctx, id)
	err := h.Update(ctx, client.ScheduleUpdateOptions{
		DoUpdate: func(in client.ScheduleUpdateInput) (*client.ScheduleUpdate, error) {
			sched := in.Description.Schedule
			wfAct, ok := sched.Action.(*client.ScheduleWorkflowAction)
			if !ok || len(wfAct.Args) == 0 {
				return nil, fmt.Errorf("schedule %q has no workflow args", id)
			}

			pl, ok := wfAct.Args[0].(*common.Payload)
			if !ok {
				return nil, fmt.Errorf("first arg not *common.Payload")
			}

			var arg scheduler.TaskScheduleWorkflowInput
			if err := json.Unmarshal(pl.Data, &arg); err != nil {
				return nil, err
			}
			arg.Notify = notify

			raw, err := json.Marshal(arg)
			if err != nil {
				return nil, err
			}
			pl.Data = raw
			return &client.ScheduleUpdate{Schedule: &sched}, nil
		},
	})
	if err != nil {
		return false, err
	}
	return true, nil
}

// RemoveMCPServer is the resolver for the removeMCPServer field.
func (r *mutationResolver) RemoveMCPServer(ctx context.Context, id string) (bool, error) {
	err := r.MCPService.RemoveMCPServer(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// StartWhatsAppConnection is the resolver for the startWhatsAppConnection field.
func (r *mutationResolver) StartWhatsAppConnection(ctx context.Context) (bool, error) {
	if r.WhatsAppService == nil {
		return false, fmt.Errorf("WhatsApp service not available")
	}

	r.WhatsAppService.TriggerConnect()

	return true, nil
}

// Activate is the resolver for the activate field.
func (r *mutationResolver) Activate(ctx context.Context, inviteCode string) (bool, error) {
	return auth.Activate(ctx, r.Logger, r.Store, inviteCode)
}

// JoinHolon is the resolver for the joinHolon field.
func (r *mutationResolver) JoinHolon(ctx context.Context, userID string, network *string) (bool, error) {
	networkName := "HolonNetwork"
	if network != nil && *network != "" {
		networkName = *network
	}

	err := r.HolonService.JoinHolonNetwork(ctx, userID, networkName)
	if err != nil {
		return false, err
	}

	return true, nil
}

// StoreToken is the resolver for the storeToken field.
func (r *mutationResolver) StoreToken(ctx context.Context, input model.StoreTokenInput) (bool, error) {
	r.Logger.Info("StoreToken called")

	err := auth.StoreToken(ctx, r.Logger, r.Store, input.Token, input.RefreshToken)
	if err != nil {
		return false, err
	}

	return true, nil
}

// AddTrackedFolder is the resolver for the addTrackedFolder field.
func (r *mutationResolver) AddTrackedFolder(ctx context.Context, input model.AddTrackedFolderInput) (*model.TrackedFolder, error) {
	absPath, err := filepath.Abs(input.Path)
	if err != nil {
		return nil, fmt.Errorf("invalid path: %w", err)
	}

	stat, err := os.Stat(absPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("path does not exist: %s", absPath)
		}
		return nil, fmt.Errorf("error accessing path: %w", err)
	}

	if !stat.IsDir() {
		return nil, fmt.Errorf("path is not a directory: %s", absPath)
	}

	cleanPath := filepath.Clean(absPath)

	existingFolders, err := r.Store.GetTrackedFolders(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting existing tracked folders: %w", err)
	}

	for _, existing := range existingFolders {
		existingCleanPath := filepath.Clean(existing.Path)

		if existingCleanPath == cleanPath {
			return nil, fmt.Errorf("folder path already being tracked: %s", cleanPath)
		}

		if strings.HasPrefix(cleanPath+string(filepath.Separator), existingCleanPath+string(filepath.Separator)) {
			return nil, fmt.Errorf("path %s is contained within already tracked folder: %s", cleanPath, existingCleanPath)
		}

		if strings.HasPrefix(existingCleanPath+string(filepath.Separator), cleanPath+string(filepath.Separator)) {
			return nil, fmt.Errorf("path %s would contain already tracked folder: %s", cleanPath, existingCleanPath)
		}
	}

	folder, err := r.Store.AddTrackedFolder(ctx, &db.CreateTrackedFolderInput{
		Path: cleanPath,
		Name: input.Name,
	})
	if err != nil {
		return nil, err
	}

	if r.DirectoryWatcher != nil {
		if err := r.DirectoryWatcher.ReloadTrackedFolders(ctx); err != nil {
			r.Logger.Warn("Failed to reload tracked folders in DirectoryWatcher", "error", err)
		}
	}

	result := &model.TrackedFolder{
		ID:        folder.ID,
		Path:      folder.Path,
		Name:      folder.Name,
		IsEnabled: folder.IsEnabled,
		CreatedAt: folder.CreatedAt,
		UpdatedAt: folder.UpdatedAt,
	}

	return result, nil
}

// DeleteTrackedFolder is the resolver for the deleteTrackedFolder field.
func (r *mutationResolver) DeleteTrackedFolder(ctx context.Context, id string) (bool, error) {
	err := r.Store.DeleteTrackedFolder(ctx, id)
	if err != nil {
		return false, err
	}

	if r.DirectoryWatcher != nil {
		if err := r.DirectoryWatcher.ReloadTrackedFolders(ctx); err != nil {
			r.Logger.Warn("Failed to reload tracked folders in DirectoryWatcher", "error", err)
		}
	}

	return true, nil
}

// UpdateTrackedFolder is the resolver for the updateTrackedFolder field.
func (r *mutationResolver) UpdateTrackedFolder(ctx context.Context, id string, input model.UpdateTrackedFolderInput) (bool, error) {
	isEnabled := true
	if input.IsEnabled != nil {
		isEnabled = *input.IsEnabled
	}

	err := r.Store.UpdateTrackedFolder(ctx, id, input.Name, isEnabled)
	if err != nil {
		return false, err
	}

	if r.DirectoryWatcher != nil {
		if err := r.DirectoryWatcher.ReloadTrackedFolders(ctx); err != nil {
			r.Logger.Warn("Failed to reload tracked folders in DirectoryWatcher", "error", err)
		}
	}

	return true, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*model.UserProfile, error) {
	if r.Store == nil {
		panic("Store not initialized")
	}

	profile, err := r.Store.GetUserProfile(ctx)
	if err != nil {
		return nil, err
	}

	return profile, nil
}

// GetChats is the resolver for the getChats field.
func (r *queryResolver) GetChats(ctx context.Context, first int32, offset int32) ([]*model.Chat, error) {
	chats, err := r.TwinChatService.GetChats(ctx)
	if err != nil {
		return nil, err
	}
	return chats, nil
}

// GetChat is the resolver for the getChat field.
func (r *queryResolver) GetChat(ctx context.Context, id string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, id)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// GetDataSources is the resolver for the getDataSources field.
func (r *queryResolver) GetDataSources(ctx context.Context) ([]*model.DataSource, error) {
	dbDataSources, err := r.Store.GetDataSources(ctx)
	if err != nil {
		return nil, err
	}

	modelDataSources := make([]*model.DataSource, len(dbDataSources))
	for i, ds := range dbDataSources {
		// Compute IsProcessed based on processed_path being non-null
		isProcessed := ds.ProcessedPath != nil && *ds.ProcessedPath != ""

		// Get HasError from database (default to false if null)
		hasError := ds.HasError != nil && *ds.HasError

		// Get IsIndexed from database (default to false if null)
		isIndexed := ds.IsIndexed != nil && *ds.IsIndexed

		// Determine IndexProgress based on processing status
		var indexProgress int32 = 0
		if isProcessed && !isIndexed {
			// If processed but not indexed, show some progress
			// This will be updated by the subscription for real-time progress
			if ds.ProcessingStatus == "indexing" {
				indexProgress = 10 // Show some progress for active indexing
			}
		} else if isIndexed {
			indexProgress = 100 // Complete
		}

		modelDataSources[i] = &model.DataSource{
			ID:            ds.ID,
			Name:          ds.Name,
			Path:          ds.Path,
			UpdatedAt:     ds.UpdatedAt,
			IsProcessed:   isProcessed,
			IsIndexed:     isIndexed,
			IndexProgress: indexProgress,
			HasError:      hasError,
		}
	}
	return modelDataSources, nil
}

// GetOAuthStatus is the resolver for the getOAuthStatus field.
func (r *queryResolver) GetOAuthStatus(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := r.Store.GetOAuthStatus(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// GetConnectedAccounts is the resolver for the getConnectedAccounts field.
func (r *queryResolver) GetConnectedAccounts(ctx context.Context) ([]*model.OAuthAccount, error) {
	// Get all OAuth tokens from the database
	allTokens, err := r.Store.GetAllOAuthTokens(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get OAuth tokens: %w", err)
	}

	// Convert to OAuthAccount model
	accounts := make([]*model.OAuthAccount, 0, len(allTokens))
	for _, token := range allTokens {
		// Check if token is still active (not expired and not in error state)
		isActive := !token.Error && (token.ExpiresAt.IsZero() || token.ExpiresAt.After(time.Now()))

		account := &model.OAuthAccount{
			Provider:  token.Provider,
			Username:  token.Username,
			ExpiresAt: token.ExpiresAt.Format(time.RFC3339),
			IsActive:  isActive,
		}
		accounts = append(accounts, account)
	}

	return accounts, nil
}

// GetChatSuggestions is the resolver for the getChatSuggestions field.
func (r *queryResolver) GetChatSuggestions(ctx context.Context, chatID string) ([]*model.ChatSuggestionsCategory, error) {
	return r.TwinChatService.GetChatSuggestions(ctx, chatID)
}

// GetMCPServers is the resolver for the getMCPServers field.
func (r *queryResolver) GetMCPServers(ctx context.Context) ([]*model.MCPServerDefinition, error) {
	return r.MCPService.GetMCPServers(ctx)
}

// GetTools is the resolver for the getTools field.
func (r *queryResolver) GetTools(ctx context.Context) ([]*model.Tool, error) {
	tools, err := r.MCPService.GetTools(ctx)
	if err != nil {
		return nil, err
	}

	toolsDefinitions := make([]*model.Tool, len(tools))
	for i, tool := range tools {
		toolsDefinitions[i] = &model.Tool{
			Name:        tool.Name,
			Description: tool.Description,
		}
	}
	return toolsDefinitions, nil
}

// GetWhatsAppStatus is the resolver for the getWhatsAppStatus field.
func (r *queryResolver) GetWhatsAppStatus(ctx context.Context) (*model.WhatsAppStatus, error) {
	if r.WhatsAppService == nil {
		return nil, fmt.Errorf("WhatsApp service not available")
	}

	// Get the latest QR event to ensure we have the most up-to-date information
	latestQREvent := whatsapp.GetLatestQREvent()

	isConnected := r.WhatsAppService.IsConnected()
	var qrCodeData *string

	// If we have a latest QR event, use its data
	if latestQREvent != nil {
		switch latestQREvent.Event {
		case "success":
			isConnected = true
			qrCodeData = nil
		case "code":
			isConnected = false
			qrCodeData = &latestQREvent.Code
		}
	} else {
		qrCodeData = r.WhatsAppService.GetCurrentQRCode()
	}

	statusMessage := ""
	if isConnected {
		statusMessage = "WhatsApp is connected and ready."
	} else if qrCodeData != nil {
		statusMessage = "Scan the QR code to connect WhatsApp."
	} else {
		statusMessage = "Start WhatsApp connection to get a QR code."
	}

	return &model.WhatsAppStatus{
		IsConnected:   isConnected,
		QRCodeData:    qrCodeData,
		StatusMessage: statusMessage,
	}, nil
}

// GetAgentTasks is the resolver for the getAgentTasks field.
func (r *queryResolver) GetAgentTasks(ctx context.Context) ([]*model.AgentTask, error) {
	iterator, err := r.TemporalClient.ScheduleClient().List(ctx, client.ScheduleListOptions{})
	if err != nil {
		return nil, err
	}

	agentTasks := make([]*model.AgentTask, 0)
	for iterator.HasNext() {
		schedule, err := iterator.Next()
		if err != nil {
			return nil, err
		}

		if schedule == nil {
			continue
		}

		if schedule.WorkflowType.Name != "TaskScheduleWorkflow" {
			continue
		}

		handle := r.TemporalClient.ScheduleClient().GetHandle(ctx, schedule.ID)
		desc, err := handle.Describe(ctx)
		if err != nil {
			return nil, err
		}
		createdAt := desc.Info.CreatedAt.Format(time.RFC3339)
		updatedAt := desc.Info.LastUpdateAt.Format(time.RFC3339)

		var wfArgsData scheduler.TaskScheduleWorkflowInput
		if wf, ok := desc.Schedule.Action.(*client.ScheduleWorkflowAction); ok {
			for i, arg := range wf.Args {
				if payload, ok := arg.(*common.Payload); ok {
					err := json.Unmarshal(payload.Data, &wfArgsData)
					if err != nil {
						fmt.Printf("json.Unmarshal error: %v\n", err)
						return nil, err
					}
				} else {
					r.Logger.Debug("wf.Args[%d] is NOT *common.Payload, type: %T\n", i, arg)
				}
			}
		}

		scheduleStr := ""
		if wfArgsData.Delay > 0 {
			if len(schedule.NextActionTimes) == 0 {
				continue
			}
			nextActionTime := schedule.NextActionTimes[0]
			now := time.Now()
			nextExecutingIn := nextActionTime.Sub(now)
			days := int(nextExecutingIn.Hours()) / 24
			hours := int(nextExecutingIn.Hours()) % 24
			minutes := int(nextExecutingIn.Minutes()) % 60

			switch {
			case days > 0 && hours > 0:
				scheduleStr += fmt.Sprintf("In %d Days %d Hours %d Minutes", days, hours, minutes)
			case days > 0:
				scheduleStr += fmt.Sprintf("In %d Days %d Minutes", days, minutes)
			case hours > 0:
				scheduleStr += fmt.Sprintf("In %d Hours %d Minutes", hours, minutes)
			default:
				scheduleStr += fmt.Sprintf("In %d Minutes", minutes)
			}
		} else {
			exprDesc, _ := cron.NewDescriptor()
			cronDesc, err := exprDesc.ToDescription(wfArgsData.Cron, cron.Locale_en)
			if err != nil {
				r.Logger.Error("Failed to get cron description", "error", err)
				continue
			}
			scheduleStr = cronDesc
		}

		task := &model.AgentTask{
			ID:           schedule.ID,
			Name:         wfArgsData.Name,
			Schedule:     scheduleStr,
			Plan:         helpers.Ptr(wfArgsData.Task),
			CreatedAt:    createdAt,
			UpdatedAt:    updatedAt,
			CompletedAt:  nil,
			TerminatedAt: nil,
			Output:       nil,
			Notify:       wfArgsData.Notify,
		}
		agentTasks = append(agentTasks, task)
	}
	sort.Slice(agentTasks, func(i, j int) bool {
		return agentTasks[i].ID > agentTasks[j].ID
	})
	return agentTasks, nil
}

// GetSetupProgress is the resolver for the getSetupProgress field.
func (r *queryResolver) GetSetupProgress(ctx context.Context) ([]*model.SetupProgress, error) {
	type subjectInfo struct {
		subject  string
		name     string
		required bool
	}
	subjects := []subjectInfo{
		{"setup_progress.kokoro", "kokoro", false},
		{"setup_progress.postgres", "postgres", true},
	}
	results := make([]*model.SetupProgress, 0, len(subjects))

	for _, s := range subjects {
		msg, err := r.Nc.Request(s.subject, nil, 250*time.Millisecond)
		if err != nil || msg == nil {
			results = append(results, &model.SetupProgress{Name: s.name, Progress: 0, Required: s.required})
			continue
		}
		var progress model.SetupProgress
		if err := json.Unmarshal(msg.Data, &progress); err != nil {
			results = append(results, &model.SetupProgress{Name: s.name, Progress: 0, Required: s.required})
			continue
		}
		results = append(results, &progress)
	}
	return results, nil
}

// WhitelistStatus is the resolver for the whitelistStatus field.
func (r *queryResolver) WhitelistStatus(ctx context.Context) (bool, error) {
	return auth.IsWhitelisted(ctx, r.Logger, r.Store)
}

// GetHolons is the resolver for the getHolons field.
func (r *queryResolver) GetHolons(ctx context.Context, userID string) ([]string, error) {
	return r.HolonService.GetHolons(ctx, userID)
}

// GetThreads is the resolver for the getThreads field.
func (r *queryResolver) GetThreads(ctx context.Context, network *string, first int32, offset int32) ([]*model.Thread, error) {
	return r.HolonService.GetThreads(ctx, first, offset)
}

// GetThread is the resolver for the getThread field.
func (r *queryResolver) GetThread(ctx context.Context, network *string, id string) (*model.Thread, error) {
	return r.HolonService.GetThread(ctx, id)
}

// GetTrackedFolders is the resolver for the getTrackedFolders field.
func (r *queryResolver) GetTrackedFolders(ctx context.Context) ([]*model.TrackedFolder, error) {
	dbFolders, err := r.Store.GetTrackedFolders(ctx)
	if err != nil {
		return nil, err
	}

	modelFolders := make([]*model.TrackedFolder, len(dbFolders))
	for i, folder := range dbFolders {
		modelFolders[i] = &model.TrackedFolder{
			ID:        folder.ID,
			Path:      folder.Path,
			Name:      folder.Name,
			IsEnabled: folder.IsEnabled,
			CreatedAt: folder.CreatedAt,
			UpdatedAt: folder.UpdatedAt,
		}
	}
	return modelFolders, nil
}

// GetDirectoryWatcherStatus is the resolver for the getDirectoryWatcherStatus field.
func (r *queryResolver) GetDirectoryWatcherStatus(ctx context.Context) (*model.DirectoryWatcherStatus, error) {
	r.Logger.Info("🔍 GetDirectoryWatcherStatus called")

	status := &model.DirectoryWatcherStatus{
		IsRunning:            false,
		WatchedDirectories:   []string{},
		TrackedFoldersFromDb: []*model.TrackedFolder{},
	}

	// Check if DirectoryWatcher exists
	if r.DirectoryWatcher == nil {
		r.Logger.Warn("⚠️ DirectoryWatcher is nil")
		errorMsg := "DirectoryWatcher is not initialized"
		status.ErrorMessage = &errorMsg
		return status, nil
	}

	// Get tracked folders from database
	dbFolders, err := r.Store.GetTrackedFolders(ctx)
	if err != nil {
		r.Logger.Error("❌ Failed to get tracked folders from database", "error", err)
		errorMsg := fmt.Sprintf("Database error: %v", err)
		status.ErrorMessage = &errorMsg
		return status, nil
	}

	// Convert to GraphQL model
	for _, folder := range dbFolders {
		status.TrackedFoldersFromDb = append(status.TrackedFoldersFromDb, &model.TrackedFolder{
			ID:        folder.ID,
			Path:      folder.Path,
			Name:      folder.Name,
			IsEnabled: folder.IsEnabled,
			CreatedAt: folder.CreatedAt,
			UpdatedAt: folder.UpdatedAt,
		})
	}

	watchedDirs := r.DirectoryWatcher.GetWatchedDirectories()
	status.WatchedDirectories = watchedDirs
	status.IsRunning = len(watchedDirs) > 0

	if err := r.DirectoryWatcher.GetTrackedFoldersFromDB(ctx); err != nil {
		r.Logger.Error("❌ Failed to log tracked folders from DB", "error", err)
	}

	return status, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	messages := make(chan *model.Message)
	subject := fmt.Sprintf("chat.%s", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var message model.Message
		err := json.Unmarshal(msg.Data, &message)
		if err != nil {
			r.Logger.Info("unmarshal error", "Error parsing message: %v", err)
			return
		}

		messages <- &message
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(messages)
	}()

	return messages, nil
}

// ToolCallUpdated is the resolver for the toolCallUpdated field.
func (r *subscriptionResolver) ToolCallUpdated(ctx context.Context, chatID string) (<-chan *model.ToolCall, error) {
	toolCalls := make(chan *model.ToolCall)
	subject := fmt.Sprintf("chat.%s.tool_call", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var toolCall model.ToolCall
		err := json.Unmarshal(msg.Data, &toolCall)
		if err != nil {
			r.Logger.Info("unmarshal error", "Error parsing message: %v", err)
			return
		}

		toolCalls <- &toolCall
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(toolCalls)
	}()

	return toolCalls, nil
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *subscriptionResolver) IndexingStatus(ctx context.Context) (<-chan *model.IndexingStatus, error) {
	if r.Nc == nil {
		return nil, errors.New("NATS connection is nil")
	}

	if !r.Nc.IsConnected() {
		return nil, errors.New("NATS connection is not connected")
	}

	r.Logger.Info("Subscribing to indexing status",
		"connected", r.Nc.IsConnected(),
		"status", r.Nc.Status().String())

	statusChan := make(chan *model.IndexingStatus, 100)
	subject := "indexing_data"

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var status model.IndexingStatus
		err := json.Unmarshal(msg.Data, &status)
		if err != nil {
			r.Logger.Error("Failed to unmarshal indexing status",
				"error", err,
				"data", string(msg.Data))
			return
		}

		select {
		case statusChan <- &status:
		case <-ctx.Done():
			r.Logger.Info("Context canceled while sending status", "subject", msg.Subject)
			return
		default:
			r.Logger.Warn("Status channel is full, dropping message", "subject", msg.Subject)
		}
	})
	if err != nil {
		r.Logger.Error("Failed to subscribe to indexing status",
			"error", err,
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		return nil, err
	}

	go func() {
		<-ctx.Done()
		r.Logger.Info("Unsubscribing from indexing status",
			"subject", subject,
			"connected", r.Nc.IsConnected(),
			"status", r.Nc.Status().String())
		if err := sub.Unsubscribe(); err != nil {
			r.Logger.Error("Error unsubscribing", "error", err)
		}
		close(statusChan)
	}()

	return statusChan, nil
}

// NotificationAdded is the resolver for the notificationAdded field.
func (r *subscriptionResolver) NotificationAdded(ctx context.Context) (<-chan *model.AppNotification, error) {
	notificationChan := make(chan *model.AppNotification, 10)
	subject := "notifications.app"

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var notification model.AppNotification
		if err := json.Unmarshal(msg.Data, &notification); err != nil {
			return
		}
		notificationChan <- &notification
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(notificationChan)
	}()

	return notificationChan, nil
}

// MessageStream is the resolver for the messageStream subscription.
func (r *subscriptionResolver) MessageStream(ctx context.Context, chatID string) (<-chan *model.MessageStreamPayload, error) {
	subject := fmt.Sprintf("chat.%s.stream", chatID)
	ch := make(chan *model.MessageStreamPayload, 12) // small buffer

	sub, err := r.Nc.Subscribe(subject, func(m *nats.Msg) {
		var p model.MessageStreamPayload
		if err := json.Unmarshal(m.Data, &p); err != nil {
			r.Logger.Warn("stream unmarshal error", "err", err)
			return
		}
		ch <- &p
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(ch)
	}()

	return ch, nil
}

// ProcessMessageHistoryStream is the resolver for the processMessageHistoryStream subscription.
func (r *subscriptionResolver) ProcessMessageHistoryStream(ctx context.Context, chatID string, messages []*model.MessageInput, isOnboarding bool) (<-chan *model.MessageStreamPayload, error) {
	// Convert input messages to the format expected by the service for logging purposes
	historyJson, err := json.Marshal(map[string]interface{}{
		"chatId":     chatID,
		"messages":   messages,
		"count":      len(messages),
		"onboarding": isOnboarding,
	})
	if err != nil {
		return nil, err
	}

	r.Logger.Info("Processing message history with streaming", "data", string(historyJson))

	// Use the streaming service method
	streamChan, err := r.TwinChatService.ProcessMessageHistoryStream(ctx, chatID, messages, isOnboarding)
	if err != nil {
		return nil, err
	}

	// Convert the service channel to the expected GraphQL channel
	gqlChan := make(chan *model.MessageStreamPayload, 10)

	go func() {
		defer close(gqlChan)
		for {
			select {
			case payload, ok := <-streamChan:
				if !ok {
					return
				}
				gqlChan <- &payload
			case <-ctx.Done():
				return
			}
		}
	}()

	return gqlChan, nil
}

// WhatsAppSyncStatus is the resolver for the whatsAppSyncStatus field.
func (r *subscriptionResolver) WhatsAppSyncStatus(ctx context.Context) (<-chan *model.WhatsAppSyncStatus, error) {
	whatsappSyncStatus := make(chan *model.WhatsAppSyncStatus, 10)
	subject := "whatsapp.sync.status"

	r.Logger.Info("Setting up WhatsApp sync status subscription", "subject", subject)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		if msg == nil || len(msg.Data) == 0 {
			r.Logger.Error("Received nil or empty WhatsApp sync status message")
			return
		}

		r.Logger.Debug("Received WhatsApp sync status update", "data", string(msg.Data))

		var status model.WhatsAppSyncStatus
		if err := json.Unmarshal(msg.Data, &status); err != nil {
			r.Logger.Error("Failed to unmarshal WhatsApp sync status", "error", err, "data", string(msg.Data))
			return
		}

		r.Logger.Info("Processed WhatsApp sync status",
			"isSyncing", status.IsSyncing,
			"isCompleted", status.IsCompleted,
			"statusMessage", status.StatusMessage)

		select {
		case whatsappSyncStatus <- &status:
			r.Logger.Debug("Sent WhatsApp sync status to client")
		case <-ctx.Done():
			r.Logger.Info("Context canceled while sending WhatsApp sync status")
			return
		default:
			r.Logger.Warn("WhatsApp sync status channel is full, dropping message")
		}
	})
	if err != nil {
		r.Logger.Error("Failed to subscribe to WhatsApp sync status", "error", err)
		return nil, err
	}

	initialStatus := &model.WhatsAppSyncStatus{
		IsSyncing:   false,
		IsCompleted: false,
	}

	statusMessage := "Waiting for WhatsApp sync updates..."
	initialStatus.StatusMessage = &statusMessage

	go func() {
		select {
		case whatsappSyncStatus <- initialStatus:
			r.Logger.Info("Sent initial WhatsApp sync status to client")
		case <-time.After(1 * time.Second):
			r.Logger.Warn("Timeout sending initial WhatsApp sync status")
		}
	}()

	go func() {
		<-ctx.Done()
		r.Logger.Info("Unsubscribing from WhatsApp sync status")
		if err := sub.Unsubscribe(); err != nil {
			r.Logger.Error("Error unsubscribing from WhatsApp sync status", "error", err)
		}
		close(whatsappSyncStatus)
	}()

	return whatsappSyncStatus, nil
}

// PrivacyDictUpdated is the resolver for the privacyDictUpdated field.
func (r *subscriptionResolver) PrivacyDictUpdated(ctx context.Context, chatID string) (<-chan *model.PrivacyDictUpdate, error) {
	privacyUpdateChan := make(chan *model.PrivacyDictUpdate, 10)
	subject := fmt.Sprintf("chat.%s.privacy_dict", chatID)

	sub, err := r.Nc.Subscribe(subject, func(msg *nats.Msg) {
		var update model.PrivacyDictUpdate
		if err := json.Unmarshal(msg.Data, &update); err != nil {
			r.Logger.Error("Failed to unmarshal privacy dict update", "error", err)
			return
		}

		select {
		case privacyUpdateChan <- &update:
		case <-ctx.Done():
			return
		default:
			r.Logger.Warn("Privacy update channel full, dropping update")
		}
	})
	if err != nil {
		return nil, err
	}

	go func() {
		<-ctx.Done()
		_ = sub.Unsubscribe()
		close(privacyUpdateChan)
	}()

	return privacyUpdateChan, nil
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *userProfileResolver) IndexingStatus(ctx context.Context, obj *model.UserProfile) (*model.IndexingStatus, error) {
	workflowID := "index"
	workflowRunID := "" // Empty string means latest run
	var stateQuery model.IndexingState
	encodedValue, err := r.TemporalClient.QueryWorkflow(
		ctx,
		workflowID,
		workflowRunID,
		"getIndexingState",
	)
	if err != nil {
		r.Logger.Error("Error querying workflow", "error", err)
		return nil, nil
	}

	if err := encodedValue.Get(&stateQuery); err != nil {
		r.Logger.Error("Error querying workflow", "error", err)
		return nil, nil
	}

	return &model.IndexingStatus{
		Status: stateQuery,
	}, nil
}

// ConnectedDataSources is the resolver for the connectedDataSources field.
func (r *userProfileResolver) ConnectedDataSources(ctx context.Context, obj *model.UserProfile) ([]*model.DataSource, error) {
	panic(fmt.Errorf("not implemented: ConnectedDataSources - connectedDataSources"))
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// UserProfile returns UserProfileResolver implementation.
func (r *Resolver) UserProfile() UserProfileResolver { return &userProfileResolver{r} }

type (
	chatResolver         struct{ *Resolver }
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
	userProfileResolver  struct{ *Resolver }
)
