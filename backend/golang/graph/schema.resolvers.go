package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/EternisAI/enchanted-twin/graph/model"
	"github.com/EternisAI/enchanted-twin/pkg/helpers"
	"github.com/google/uuid"
	"go.temporal.io/sdk/client"
)

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *model.Chat) ([]*model.Message, error) {
	return r.TwinChatService.GetMessagesByChatId(ctx, obj.ID)
}

// StartOAuthFlow is the resolver for the startOAuthFlow field.
func (r *mutationResolver) StartOAuthFlow(ctx context.Context, provider string, scope string) (*model.OAuthFlow, error) {
	auth, redir, err := helpers.StartOAuthFlow(ctx, r.Logger, r.Store, provider, scope)
	return &model.OAuthFlow{
		AuthURL:     auth,
		RedirectURI: redir,
	}, err
}

// CompleteOAuthFlow is the resolver for the completeOAuthFlow field.
func (r *mutationResolver) CompleteOAuthFlow(ctx context.Context, state string, authCode string) (string, error) {
	return helpers.CompleteOAuthFlow(ctx, r.Logger, r.Store, state, authCode)
}

// RefreshExpiredOAuthTokens is the resolver for the refreshExpiredOAuthTokens field.
func (r *mutationResolver) RefreshExpiredOAuthTokens(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := helpers.RefreshExpiredTokens(ctx, r.Logger, r.Store)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (bool, error) {
	// Use SQLite for profile updates
	return r.Store.UpdateUserProfile(ctx, input)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, name string) (*model.Chat, error) {
	chat, err := r.TwinChatService.CreateChat(ctx, name)
	if err != nil {
		return nil, err
	}
	return &chat, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, text string) (*model.Message, error) {
	subject := fmt.Sprintf("chat.%s", chatID)

	userMessageJson, err := json.Marshal(model.Message{
		ID:        uuid.New().String(),
		Text:      &text,
		CreatedAt: time.Now().Format(time.RFC3339),
		Role:      model.RoleUser,
	})
	if err != nil {
		return nil, err
	}
	err = r.Nc.Publish(subject, userMessageJson)
	if err != nil {
		return nil, err
	}

	return r.TwinChatService.SendMessage(ctx, chatID, text)
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, chatID string) (*model.Chat, error) {
	chat, err := r.TwinChatService.GetChat(ctx, chatID)
	if err != nil {
		return nil, fmt.Errorf("chat not found")
	}

	err = r.TwinChatService.DeleteChat(ctx, chatID)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// StartIndexing is the resolver for the startIndexing field.
func (r *mutationResolver) StartIndexing(ctx context.Context) (bool, error) {
	options := client.StartWorkflowOptions{
		ID:        "index",
		TaskQueue: "default",
	}
	_, err := (r.TemporalClient).ExecuteWorkflow(ctx, options, "IndexWorkflow", map[string]interface{}{})
	if err != nil {
		return false, fmt.Errorf("error executing workflow: %v", err)
	}

	return true, nil
}

// AddDataSource is the resolver for the addDataSource field.
func (r *mutationResolver) AddDataSource(ctx context.Context, name string, path string) (bool, error) {
	_, err := r.Store.CreateDataSource(ctx, uuid.New().String(), name, path)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteDataSource is the resolver for the deleteDataSource field.
func (r *mutationResolver) DeleteDataSource(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteDataSource - deleteDataSource"))
}

// ConnectMCPServer is the resolver for the connectMCPServer field.
func (r *mutationResolver) ConnectMCPServer(ctx context.Context, input model.ConnectMCPServerInput) (bool, error) {
	_, err := r.MCPService.ConnectMCPServer(ctx, input)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context) (*model.UserProfile, error) {
	panic(fmt.Errorf("not implemented: Profile - profile"))
}

// GetChats is the resolver for the getChats field.
func (r *queryResolver) GetChats(ctx context.Context, first int32, offset int32) ([]*model.Chat, error) {
	panic(fmt.Errorf("not implemented: GetChats - getChats"))
}

// GetChat is the resolver for the getChat field.
func (r *queryResolver) GetChat(ctx context.Context, id string) (*model.Chat, error) {
	panic(fmt.Errorf("not implemented: GetChat - getChat"))
}

// GetDataSources is the resolver for the getDataSources field.
func (r *queryResolver) GetDataSources(ctx context.Context) ([]*model.DataSource, error) {
	panic(fmt.Errorf("not implemented: GetDataSources - getDataSources"))
}

// GetOAuthStatus is the resolver for the getOAuthStatus field.
func (r *queryResolver) GetOAuthStatus(ctx context.Context) ([]*model.OAuthStatus, error) {
	dbResults, err := r.Store.GetOAuthStatus(ctx)
	if err != nil {
		return nil, err
	}
	results := make([]*model.OAuthStatus, len(dbResults))
	for i, item := range dbResults {
		db := item.ToModel()
		results[i] = &db
	}
	return results, nil
}

// GetChatSuggestions is the resolver for the getChatSuggestions field.
func (r *queryResolver) GetChatSuggestions(ctx context.Context, chatID string) ([]*model.ChatSuggestionsCategory, error) {
	return r.TwinChatService.GetChatSuggestions(ctx, chatID)
}

// GetMCPServers is the resolver for the getMCPServers field.
func (r *queryResolver) GetMCPServers(ctx context.Context) ([]*model.MCPServerDefinition, error) {
	return r.MCPService.GetMCPServers(ctx)
}

// GetTools is the resolver for the getTools field.
func (r *queryResolver) GetTools(ctx context.Context) ([]*model.Tool, error) {
	tools, err := r.MCPService.GetTools(ctx)
	if err != nil {
		return nil, err
	}

	toolsDefinitions := make([]*model.Tool, len(tools))
	for i, tool := range tools {
		toolsDefinitions[i] = &model.Tool{
			Name:        tool.Name,
			Description: *tool.Description,
		}
	}
	return toolsDefinitions, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	panic(fmt.Errorf("not implemented: MessageAdded - messageAdded"))
}

// ToolCallUpdated is the resolver for the toolCallUpdated field.
func (r *subscriptionResolver) ToolCallUpdated(ctx context.Context, chatID string) (<-chan *model.ToolCall, error) {
	panic(fmt.Errorf("not implemented: ToolCallUpdated - toolCallUpdated"))
}

// IndexingStatus is the resolver for the indexingStatus field.
func (r *subscriptionResolver) IndexingStatus(ctx context.Context) (<-chan *model.IndexingStatus, error) {
	panic(fmt.Errorf("not implemented: IndexingStatus - indexingStatus"))
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type chatResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
